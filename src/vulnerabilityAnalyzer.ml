open Core


let batch_size = 10

let get_reentrant_calls db =
  `List (List.map ~f:ReentrantCall.to_json (ReentrantCall.aggregate_calls db))

let get_tod_txs db =
  let tod_txs = FactDb.query5 db FactDb.Relations.tod in
  let f (b, address, tx1, tx2, key) = `Assoc [
    ("block", `Int b);
    ("address", `String (BigInt.to_hex ~length:40 address));
    ("tx1", `String tx1);
    ("tx2", `String tx2);
    ("key", `String (BigInt.to_string key));
  ] in
  `List (List.map ~f tod_txs)

let get_empty_delegates db =
  let empty_delegate = FactDb.get_rel1 ~k:FactDb.Types.bigint_key "empty_delegate" in
  let result = FactDb.query1 db empty_delegate in
  let f address = `String (BigInt.to_hex ~length:40 address) in
  `List (List.map ~f result)

let get_unhandled_exceptions db =
  let result = FactDb.query3 db FactDb.Relations.failed_call in
  let f (id, address, value) = `Assoc [
    ("trace_id", `Int id);
    ("address", `String (BigInt.to_hex ~length:40 address));
    ("value", `String (BigInt.to_string value));
  ] in
  `List (List.map ~f result)

let get_integer_overflows db =
  let result = FactDb.query5 db FactDb.Relations.overflow in
  let f (id, signed, bits, expected, actual) = `Assoc [
    ("trace_id", `Int id);
    ("signed", `Bool signed);
    ("bits", `Int bits);
    ("expected", `String (BigInt.to_string expected));
    ("actual", `String (BigInt.to_string actual));
  ] in
  `List (List.map ~f result)

let get_unrestricted_actions db =
  let unsafe_selfdestructs_results = FactDb.query2 db FactDb.Relations.unsafe_selfdestruct in
  let format_unsafe_selfdestruct (id, address) = `Assoc [
    ("type", `String "unsafe-selfdestruct");
    ("id", `Int id);
    ("address", `String (BigInt.to_hex ~length:40 address));
  ]
  in
  let unsafe_selfdestructs = List.map ~f:format_unsafe_selfdestruct unsafe_selfdestructs_results in

  let unsafe_sstore_results = FactDb.query2 db FactDb.Relations.unsafe_sstore in
  let format_unsafe_sstore (id, key) = `Assoc [
    ("type", `String "unsafe-sstore");
    ("id", `Int id);
    ("key", `String (BigInt.to_hex key));
  ]
  in
  let unsafe_sstores = List.map ~f:format_unsafe_sstore unsafe_sstore_results in

  let unsafe_call_results = FactDb.query3 db FactDb.Relations.unsafe_call in
  let format_unsafe_call (id, address, value) = `Assoc [
    ("type", `String "unsafe-call");
    ("id", `Int id);
    ("address", `String (BigInt.to_hex ~length:40 address));
    ("value", `String (BigInt.to_string value));
  ]
  in
  let unsafe_calls = List.map ~f:format_unsafe_call unsafe_call_results in

  let unsafe_delegate_call_results = FactDb.query2 db FactDb.Relations.unsafe_delegate_call in
  let format_unsafe_delegate_call (id, address) = `Assoc [
    ("type", `String "unsafe-delegate-call");
    ("id", `Int id);
    ("address", `String (BigInt.to_hex ~length:40 address));
  ]
  in
  let unsafe_delegate_calls = List.map ~f:format_unsafe_delegate_call unsafe_delegate_call_results in

  `List (unsafe_selfdestructs @ unsafe_sstores @ unsafe_calls @ unsafe_delegate_calls)

let get_final_results db vulnerability_type =
  match vulnerability_type with
  | "tod" -> get_tod_txs db
  | _ -> failwithf "unknown vulnerability %s" vulnerability_type ()

let get_results db vulnerability_type =
  let module T = FactDb.Types in

  match vulnerability_type with
  | "integer-overflow" -> get_integer_overflows db
  | "unhandled-exception" -> get_unhandled_exceptions db
  | "locked-ether" -> get_empty_delegates db
  | "reentrancy" -> get_reentrant_calls db
  | "tod" -> `List []
  | "unrestricted-action" -> get_unrestricted_actions db
  | _ -> failwithf "unknown vulnerability %s" vulnerability_type ()

let make_connection () = PgDb.create (Sys.getenv_exn "DATABASE_URL")

let per_block_vulnerabilities = ["tod"]
let per_tx_vulnerabilities = [
  "integer-overflow"; "unhandled-exception"; "locked-ether";
  "reentrancy"; "tod"; "unrestricted-action";
]

let is_per_contract vulnerability = match vulnerability with
  | "tod" -> false
  | _ -> true

let analyze_contracts ~file ~timeout ~vulnerability_type contracts =
  let open PgMonad.Let_syntax in

  let include_indirect_transactions = match vulnerability_type with
  | "reentrancy" -> true
  | _ -> false
  in

  let get_initial_db () = match vulnerability_type with
  | "tod" -> Some (FactDb.create ())
  | _     -> None
  in

  let per_contract = is_per_contract vulnerability_type in

  let taggers = Taggers.for_vulnerability vulnerability_type in

  let total_count = List.length contracts in

  let%bind connection_pool = PgMonad.all (List.init ~f:(fun _ -> make_connection ()) batch_size) in
  let get_db i = List.nth_exn connection_pool i in

  let analyze_transaction ~db ~tracer struct_logs =
    let traces = TraceParser.parse_json struct_logs in
    let (db, _) = Tracer.execute_traces ?db tracer traces in
    if per_contract
      then get_results db vulnerability_type
      else `List []
  in

  let try_analyze_transaction ~db ~tracer raw_trace =
    let open Yojson.Safe.Util in
    let trace = Yojson.Safe.from_string raw_trace in
    match member "failed" trace, member "structLogs" trace with
    | `Bool false, (`List _ as struct_logs) ->
      analyze_transaction ~db ~tracer struct_logs
    | _ -> `List []
  in

  let trace_transaction db (tx_hash, traces, address, block_number) =
    let tracer = Tracer.create ~tx_hash ~taggers ~block_number address in
    try
      let result = try_analyze_transaction ~db ~tracer traces in
      (tx_hash, result)
    with e ->
      Logs.err (fun m -> m "%s failed: %s" tx_hash (Exn.to_string e));
      (tx_hash, `List [])
  in

  let analyze_contract index contract =
    let start = Unix.gettimeofday () in
    let pg_db = get_db index in
    let fact_db = get_initial_db () in
    let rec run_analysis offset acc =
      Logs.debug (fun m -> m "processed %d txs for %s" offset contract);
      let%bind transactions =
        PgDb.get_contract_transactions pg_db
            ~include_indirect:include_indirect_transactions ~offset contract in
      Logs.debug (fun m -> m "fetched %d transactions" (List.length transactions));
      let ellapsed_time = Unix.gettimeofday () -. start in
      let has_timeout = ellapsed_time > timeout in
      if List.is_empty transactions || has_timeout
        then PgMonad.return (acc, has_timeout)
        else
          let not_list_empty (_, t) = not (List.is_empty (Yojson.Safe.Util.to_list t)) in
          let results =
            transactions
            |> List.map ~f:(trace_transaction fact_db)
            |> List.filter ~f:not_list_empty
          in
          run_analysis (offset + List.length transactions) (acc @ results)
    in
    let%bind (result, has_timeout) = run_analysis 0 [] in
    let json_result =
      if per_contract
        then `Assoc result
        else get_final_results (Option.value_exn fact_db) vulnerability_type
    in
    let json = `Assoc [("address", `String contract);
                       ("result", json_result);
                       ("timeout", `Bool has_timeout)] in
    PgMonad.lift (Lwt_io.fprintf file "%s\n" (Yojson.Safe.to_string json))
  in

  let rec run_full_analysis contracts i acc =
    Logs.info (fun m -> m "progress: %d/%d" i total_count);

    match contracts with
    | [] -> PgMonad.return (List.rev acc)
    | contracts_list ->
      let (batch, rest) = List.split_n contracts_list batch_size in
      let%bind results = PgMonad.all (List.mapi ~f:analyze_contract batch) in
      run_full_analysis rest (i + (List.length batch)) (results @ acc)
  in
  run_full_analysis contracts 0 []

let remove_checked_contracts contracts output = match Sys.file_exists output with
  | `No | `Unknown -> contracts
  | `Yes ->
    let open Yojson.Safe.Util in
    let get_address line = line |> Yojson.Safe.from_string |> member "address" |> to_string in
    let existing = List.map ~f:get_address (In_channel.read_lines output) |> String.Set.of_list in
    let exists contract = Set.exists ~f:((=) contract) existing in
    List.filter contracts ~f:(Fn.compose not exists)

let analyze_vulnerabilities ?addresses ?(timeout=120.) vulnerability_type ~output =
  let open PgMonad.Let_syntax in

  let%bind pg_db = make_connection () in
  let%bind contracts = match addresses with
  | Some v -> PgMonad.return v
  | None -> PgDb.get_vulnerable_contracts pg_db vulnerability_type
  in
  let%bind () = PgDb.disconnect pg_db in
  let unchecked_contracts = remove_checked_contracts contracts output in

  let total_count = List.length unchecked_contracts in
  Logs.info (fun m -> m "analyzing %d contracts" total_count);

  let run file = analyze_contracts ~timeout ~file ~vulnerability_type unchecked_contracts in

  let flags = [Unix.O_APPEND; Unix.O_CREAT; Unix.O_WRONLY; Unix.O_CLOEXEC] in
  PgMonad.ignore_m (Lwt_io.with_file ~flags ~mode:Lwt_io.Output output run)


module AnalysisState = struct
  type t = {
    filename: string;
    last_block: int;
    block_db: FactDb.t;
    lines_count: int;
    total_lines_count: int;
    timeouts_count: int;
    traces_count: int64;
    failed_count: int;
    timings: (int * float) list;
  }

  let create filename total_lines_count = {
    filename;
    last_block = 0;
    block_db = FactDb.create ();
    lines_count = 0;
    total_lines_count;
    timeouts_count = 0;
    traces_count = 0L;
    failed_count = 0;
    timings = [];
  }

  let set_last_block t block =
    if t.last_block = block then (t, t.block_db, t.last_block)
    else ({ t with last_block = block; block_db = FactDb.create () }, t.block_db, t.last_block)
  let incr_lines_count t = { t with lines_count = t.lines_count + 1 }
  let incr_failed_count t = { t with failed_count = t.failed_count + 1 }
  let incr_timeouts_count t = { t with timeouts_count = t.timeouts_count + 1 }
  let add_traces_count t count = { t with traces_count = Int64.(t.traces_count + count) }
  let add_timing t timing = { t with timings = timing :: t.timings }

  let to_json t = `Assoc [
    ("filename", `String t.filename);
    ("lines_count", `Int t.lines_count);
    ("total_lines_count", `Int t.total_lines_count);
    ("timeouts_count", `Int t.timeouts_count);
    ("traces_count", `Intlit (Int64.to_string t.traces_count));
    ("failed_count", `Int t.failed_count);
  ]

  let to_json_with_timestats t =
    let obj = to_json t in
    let total_time = List.sum (module Float) ~f:snd t.timings in
    let timings = List.map ~f:snd t.timings in
    let traces_counts = List.map ~f:fst t.timings in
    let max_timing = List.max_elt ~compare:Float.compare timings in
    let min_traces_count = List.min_elt ~compare:Int.compare traces_counts in
    let max_traces_count = List.max_elt ~compare:Int.compare traces_counts in
    let timestats = `Assoc [
      ("total_time", `Float total_time);
      ("mean_traces_count", `Float (Util.mean (List.map ~f:Int.to_float traces_counts)));
      ("stdev_traces_count", `Float (Util.stdev (List.map ~f:Int.to_float traces_counts)));
      ("min_traces_count", `Int (Option.value_exn min_traces_count));
      ("max_traces_count", `Int (Option.value_exn max_traces_count));
      ("max_time", `Float (Option.value_exn max_timing));
      ("mean_time", `Float (Util.mean timings));
      ("stdev_time", `Float (Util.stdev timings));
      ("mean_per_op", `Float (total_time /. (Int64.to_float t.traces_count)));
    ] in
    Yojson.Safe.Util.combine obj (`Assoc [("timestats", timestats)])
end


let ouptut_json_line json output =
  Yojson.Safe.to_channel output json;
  Out_channel.newline output

let output_block_line block vulnerability vulnerabilities output =
  let json_result = `Assoc [
    ("block", `Int block);
    ("vulnerability", `String vulnerability);
    ("vulnerabilities", vulnerabilities);
  ] in
  ouptut_json_line json_result output

let output_tx_line transaction timeout vulnerability vulnerabilities output =
  let json_result = `Assoc [
    ("tx", EthTypes.SimpleTransaction.to_json transaction);
    ("timeout", `Bool timeout);
    ("vulnerability", `String vulnerability);
    ("vulnerabilities", vulnerabilities);
  ] in
  ouptut_json_line json_result output


let output_block_vulnerabilities db block output =
  let f vuln =
    match get_final_results db vuln with
    | `List [] -> ()
    | vulns -> output_block_line block vuln vulns output
  in
  List.iter per_block_vulnerabilities ~f

let run_analyze_transactions_file ?timeout ~check_all ~vulnerability_mapping filename output =
  let (module ChannelImpl: Channel.S) = Channel.module_for filename in

  let compute_vulnerabilities block_db transaction vulnerabilities =
    let open EthTypes in
    let open SimpleTransaction in

    (* per tx logic *)
    let taggers = Taggers.per_tx in
    (* let taggers = Taggers.for_vulnerability vulnerability in *)
    let tracer = Tracer.create ~tx_hash:transaction.hash ~taggers
                               ~block_number:transaction.block_number transaction.to_ in
    let traces = transaction.result.ExecutionResult.traces in
    let start_time = Unix.gettimeofday () in
    let (db, did_timeout) = Tracer.execute_traces ?timeout tracer traces in
    let output_vuln vulnerability = match get_results db vulnerability, did_timeout with
    | (`List (_ :: _) as vulnerabilities, _) | (vulnerabilities, true) ->
      output_tx_line transaction did_timeout vulnerability vulnerabilities output
    | _ -> () in
    let ellapsed = if did_timeout then None else Some (Unix.gettimeofday () -. start_time) in
    List.iter ~f:output_vuln vulnerabilities;

    (* per bock logic *)
    let per_block_tracer = Tracer.create ~tx_hash:transaction.hash ~taggers:Taggers.per_block
                                           ~block_number:transaction.block_number transaction.to_ in
    if check_all || List.mem ~equal:String.equal vulnerabilities "tod" then
      ignore(Tracer.execute_traces ?timeout ~db:block_db per_block_tracer traces);

    ellapsed
  in

  let process_line state line =
    let open AnalysisState in
    let open EthTypes in

    if state.lines_count mod 1000 = 0 then
      Logs.info (fun m -> m "progress %s: %d/%d" filename state.lines_count state.total_lines_count);
    let state = incr_lines_count state in

    let transaction = SimpleTransaction.from_string line in
    let (state, block_db, previous_block) =
      set_last_block state transaction.SimpleTransaction.block_number
    in
    if state.last_block <> previous_block then
      output_block_vulnerabilities block_db previous_block output;

    let result = transaction.SimpleTransaction.result in

    let run_tracer () =
      let address = String.lowercase transaction.to_ in
      let vulnerabilities =
        if check_all then
          per_tx_vulnerabilities
        else
          Map.find_multi vulnerability_mapping address
      in
      let tx_traces_count = List.length result.ExecutionResult.traces in
      let ellapsed = compute_vulnerabilities state.block_db transaction vulnerabilities in
      let state = add_traces_count state (Int.to_int64 tx_traces_count) in
      match ellapsed with
      | None -> incr_timeouts_count state
      | Some t -> add_timing state (tx_traces_count, t)
    in

    if result.ExecutionResult.failed then incr_failed_count state
    else run_tracer ()
  in

  let safe_process_line acc line =
    try
      process_line acc line
    with e ->
      Logs.err (fun m -> m "error while processing %s: %s" filename (Exn.to_string e));
      acc
  in

  let total_lines_count = Channel.count_lines_wc filename in
  let process_channel ch =
    let init = AnalysisState.create filename total_lines_count in
    ChannelImpl.fold_lines ch ~init ~f:safe_process_line
  in
  let res = ChannelImpl.with_file filename ~f:process_channel in

  AnalysisState.to_json_with_timestats res

let analyze_transactions_file ?(timeout=2.) ?(check_all=true) filename ~output_dir =
  Logs.info (fun m -> m "processing %s" filename);
  let fetch_mapping =
    let open PgMonad.Let_syntax in
    let%bind db = make_connection () in
    PgDb.get_contract_vulnerabilities db
  in
  let vulnerability_mapping = PgMonad.full_run fetch_mapping in
  let output_file =
    filename
    |> Filename.basename
    |> Filename.concat output_dir
    |> Filename.chop_extension
  in
  let f out = run_analyze_transactions_file ~timeout ~check_all ~vulnerability_mapping filename out in
  let stats = Out_channel.with_file output_file ~f in
  let stats_file = Filename.concat output_dir ("stats-" ^ (Filename.basename output_file)) in
  Yojson.Safe.to_file stats_file stats;
  Logs.info (fun m -> m "done processing %s" filename)


let analyze_transactions_dir ?(timeout=2.) ?(check_all=true) input_dir ~output_dir =
  let files = Sys.readdir input_dir in
  let inputs = Parmap.A (Array.map ~f:(fun f -> Filename.concat input_dir f) files) in
  let ncores = Util.cpu_count () * 2 in
  Parmap.pariter ~ncores (analyze_transactions_file ~timeout ~check_all ~output_dir) inputs
