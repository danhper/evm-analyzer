open Core


let batch_size = 10

let get_reentrant_calls db =
  `List (List.map ~f:ReentrantCall.to_json (ReentrantCall.aggregate_calls db))

let get_tod_txs db =
  let tod_txs = FactDb.query4 db FactDb.Relations.tod in
  let f (b, tx1, tx2, key) = `Assoc [
    ("block", `Int b);
    ("tx1", `String tx1);
    ("tx2", `String tx2);
    ("key", `String (BigInt.to_string key));
  ] in
  `List (List.map ~f tod_txs)

let get_empty_delegates db =
  let empty_delegate = FactDb.get_rel1 ~k:FactDb.Types.bigint_key "empty_delegate" in
  let result = FactDb.query1 db empty_delegate in
  let f address = `String (BigInt.to_hex ~length:40 address) in
  `List (List.map ~f result)

let get_unhandled_exceptions db =
  let result = FactDb.query3 db FactDb.Relations.failed_call in
  let f (id, address, value) = `Assoc [
    ("trace_id", `Int id);
    ("address", `String (BigInt.to_hex ~length:40 address));
    ("value", `String (BigInt.to_string value));
  ] in
  `List (List.map ~f result)

let get_integer_overflows db =
  let result = FactDb.query5 db FactDb.Relations.overflow in
  let f (id, signed, bits, expected, actual) = `Assoc [
    ("trace_id", `Int id);
    ("signed", `Bool signed);
    ("bits", `Int bits);
    ("expected", `String (BigInt.to_string expected));
    ("actual", `String (BigInt.to_string actual));
  ] in
  `List (List.map ~f result)

let get_final_results db vulnerability_type =
  match vulnerability_type with
  | "tod" -> get_tod_txs db
  | _ -> failwithf "unknown vulnerability %s" vulnerability_type ()

let get_results db vulnerability_type =
  let module T = FactDb.Types in

  match vulnerability_type with
  | "integer-overflow" -> get_integer_overflows db
  | "unhandled-exception" -> get_unhandled_exceptions db
  | "locked-ether" -> get_empty_delegates db
  | "reentrancy" -> get_reentrant_calls db
  | _ -> failwithf "unknown vulnerability %s" vulnerability_type ()

let make_connection () = PgDb.create (Sys.getenv_exn "DATABASE_URL")

let analyze_contracts ~file ~timeout ~vulnerability_type contracts =
  let open PgMonad.Let_syntax in

  let include_indirect_transactions = match vulnerability_type with
  | "reentrancy" -> true
  | _ -> false
  in

  let get_initial_db () = match vulnerability_type with
  | "tod" -> Some (FactDb.create ())
  | _     -> None
  in

  let per_contract = match vulnerability_type with
  | "tod" -> false
  | _ -> true
  in

  let taggers = Taggers.for_vulnerability vulnerability_type in

  let total_count = List.length contracts in

  let%bind connection_pool = PgMonad.all (List.init ~f:(fun _ -> make_connection ()) batch_size) in
  let get_db i = List.nth_exn connection_pool i in

  let analyze_transaction ~db ~tracer struct_logs =
    let traces = TraceParser.parse_json struct_logs in
    let (db, _) = Tracer.execute_traces ?db tracer traces in
    if per_contract
      then get_results db vulnerability_type
      else `List []
  in

  let try_analyze_transaction ~db ~tracer raw_trace =
    let open Yojson.Safe.Util in
    let trace = Yojson.Safe.from_string raw_trace in
    match member "failed" trace, member "structLogs" trace with
    | `Bool false, (`List _ as struct_logs) ->
      analyze_transaction ~db ~tracer struct_logs
    | _ -> `List []
  in

  let trace_transaction db (tx_hash, traces, address, block_number) =
    let tracer = Tracer.create ~tx_hash ~taggers ~block_number address in
    try
      let result = try_analyze_transaction ~db ~tracer traces in
      (tx_hash, result)
    with e ->
      Logs.err (fun m -> m "%s failed: %s" tx_hash (Exn.to_string e));
      (tx_hash, `List [])
  in

  let analyze_contract index contract =
    let start = Unix.gettimeofday () in
    let pg_db = get_db index in
    let fact_db = get_initial_db () in
    let rec run_analysis offset acc =
      Logs.debug (fun m -> m "processed %d txs for %s" offset contract);
      let%bind transactions =
        PgDb.get_contract_transactions pg_db
            ~include_indirect:include_indirect_transactions ~offset contract in
      Logs.debug (fun m -> m "fetched %d transactions" (List.length transactions));
      let ellapsed_time = Unix.gettimeofday () -. start in
      let has_timeout = ellapsed_time > timeout in
      if List.is_empty transactions || has_timeout
        then PgMonad.return (acc, has_timeout)
        else
          let not_list_empty (_, t) = not (List.is_empty (Yojson.Safe.Util.to_list t)) in
          let results =
            transactions
            |> List.map ~f:(trace_transaction fact_db)
            |> List.filter ~f:not_list_empty
          in
          run_analysis (offset + List.length transactions) (acc @ results)
    in
    let%bind (result, has_timeout) = run_analysis 0 [] in
    let json_result =
      if per_contract
        then `Assoc result
        else get_final_results (Option.value_exn fact_db) vulnerability_type
    in
    let json = `Assoc [("address", `String contract);
                       ("result", json_result);
                       ("timeout", `Bool has_timeout)] in
    PgMonad.lift (Lwt_io.fprintf file "%s\n" (Yojson.Safe.to_string json))
  in

  let rec run_full_analysis contracts i acc =
    Logs.info (fun m -> m "progress: %d/%d" i total_count);

    match contracts with
    | [] -> PgMonad.return (List.rev acc)
    | contracts_list ->
      let (batch, rest) = List.split_n contracts_list batch_size in
      let%bind results = PgMonad.all (List.mapi ~f:analyze_contract batch) in
      run_full_analysis rest (i + (List.length batch)) (results @ acc)
  in
  run_full_analysis contracts 0 []

let remove_checked_contracts contracts output = match Sys.file_exists output with
  | `No | `Unknown -> contracts
  | `Yes ->
    let open Yojson.Safe.Util in
    let get_address line = line |> Yojson.Safe.from_string |> member "address" |> to_string in
    let existing = List.map ~f:get_address (In_channel.read_lines output) |> String.Set.of_list in
    let exists contract = Set.exists ~f:((=) contract) existing in
    List.filter contracts ~f:(Fn.compose not exists)

let analyze_vulnerabilities ?addresses ?(timeout=120.) vulnerability_type ~output =
  let open PgMonad.Let_syntax in

  let%bind pg_db = make_connection () in
  let%bind contracts = match addresses with
  | Some v -> PgMonad.return v
  | None -> PgDb.get_vulnerable_contracts pg_db vulnerability_type
  in
  let%bind () = PgDb.disconnect pg_db in
  let unchecked_contracts = remove_checked_contracts contracts output in

  let total_count = List.length unchecked_contracts in
  Logs.info (fun m -> m "analyzing %d contracts" total_count);

  let run file = analyze_contracts ~timeout ~file ~vulnerability_type unchecked_contracts in

  let flags = [Unix.O_APPEND; Unix.O_CREAT; Unix.O_WRONLY; Unix.O_CLOEXEC] in
  PgMonad.ignore_m (Lwt_io.with_file ~flags ~mode:Lwt_io.Output output run)


module AnalysisState = struct
  type t = {
    filename: string;
    lines_count: int;
    total_lines_count: int;
    timeouts_count: int;
    traces_count: int64;
    failed_count: int;
    timings: (int * float) list;
  }

  let create filename total_lines_count = {
    filename;
    lines_count = 0;
    total_lines_count;
    timeouts_count = 0;
    traces_count = 0L;
    failed_count = 0;
    timings = [];
  }

  let incr_lines_count t = { t with lines_count = t.lines_count + 1 }
  let incr_failed_count t = { t with failed_count = t.failed_count + 1 }
  let incr_timeouts_count t = { t with timeouts_count = t.timeouts_count + 1 }
  let add_traces_count t count = { t with traces_count = Int64.(t.traces_count + count) }
  let add_timing t timing = { t with timings = timing :: t.timings }

  let to_json t = `Assoc [
    ("filename", `String t.filename);
    ("lines_count", `Int t.lines_count);
    ("total_lines_count", `Int t.total_lines_count);
    ("timeouts_count", `Int t.timeouts_count);
    ("traces_count", `String (Int64.to_string t.traces_count));
    ("failed_count", `Int t.failed_count);
  ]

  let to_json_with_timestats t =
    let obj = to_json t in
    let total_time = List.sum (module Float) ~f:snd t.timings in
    let timings = List.map ~f:snd t.timings in
    let traces_counts = List.map ~f:fst t.timings in
    let max_timing = List.max_elt ~compare:Float.compare timings in
    let min_traces_count = List.min_elt ~compare:Int.compare traces_counts in
    let max_traces_count = List.max_elt ~compare:Int.compare traces_counts in
    let timestats = `Assoc [
      ("total_time", `Float total_time);
      ("mean_traces_count", `Float (Util.mean (List.map ~f:Int.to_float traces_counts)));
      ("stdev_traces_count", `Float (Util.stdev (List.map ~f:Int.to_float traces_counts)));
      ("min_traces_count", `Int (Option.value_exn min_traces_count));
      ("max_traces_count", `Int (Option.value_exn max_traces_count));
      ("max_time", `Float (Option.value_exn max_timing));
      ("mean_time", `Float (Util.mean timings));
      ("stdev_time", `Float (Util.stdev timings));
      ("mean_per_op", `Float (total_time /. (Int64.to_float t.traces_count)));
    ] in
    Yojson.Safe.Util.combine obj (`Assoc [("timestats", timestats)])
end

let run_analyze_transactions_file ?timeout filename output =
  let (module ChannelImpl: Channel.S) = Channel.module_for filename in

  let output_line transaction timeout vulnerabilities =
    let json_result = `Assoc [
      ("tx", EthTypes.SimpleTransaction.to_json transaction);
      ("timeout", `Bool timeout);
      ("vulnerabilities", vulnerabilities);
    ] in
    Yojson.Safe.to_channel output json_result;
    Out_channel.newline output
  in

  let compute_vulnerabilities transaction =
    let open EthTypes in
    let open SimpleTransaction in
    let vulnerability = "integer-overflow" in
    let taggers = Taggers.for_vulnerability vulnerability in
    let tracer = Tracer.create ~tx_hash:transaction.hash ~taggers
                               ~block_number:transaction.block_number transaction.to_ in
    let traces = transaction.result.ExecutionResult.traces in
    let start_time = Unix.gettimeofday () in
    let (db, did_timeout) = Tracer.execute_traces ?timeout tracer traces in
    let () = match get_results db vulnerability, did_timeout with
    | (`List (_ :: _) as vulnerabilities, _) | (vulnerabilities, true) ->
      output_line transaction did_timeout vulnerabilities
    | _ -> () in
    if did_timeout then None else Some (Unix.gettimeofday () -. start_time)
  in

  let process_line acc line =
    let open AnalysisState in
    let open EthTypes in

    if acc.lines_count mod 100 = 0 then
      Logs.info (fun m -> m "progress %d/%d" acc.lines_count acc.total_lines_count);
    let acc = incr_lines_count acc in

    let transaction = SimpleTransaction.from_string line in

    let result = transaction.SimpleTransaction.result in
    if result.ExecutionResult.failed then incr_failed_count acc
    else
      let tx_traces_count = List.length result.ExecutionResult.traces in
      let ellapsed = compute_vulnerabilities transaction in
      let acc = add_traces_count acc (Int.to_int64 tx_traces_count) in
      match ellapsed with
      | None -> incr_timeouts_count acc
      | Some t -> add_timing acc (tx_traces_count, t)
  in
  let total_lines_count = Channel.count_lines_wc filename in
  let process_channel ch =
    let init = AnalysisState.create filename total_lines_count in
    ChannelImpl.fold_lines ch ~init ~f:process_line
  in
  let res = ChannelImpl.with_file filename ~f:process_channel in

  Yojson.Safe.to_channel stdout (AnalysisState.to_json_with_timestats res);
  Out_channel.newline stdout

let analyze_transactions_file ?(timeout=1.) filename ~output_dir =
  let output_file = Filename.concat output_dir (Filename.basename filename) in
  let output_file = Filename.chop_extension output_file in
  Out_channel.with_file output_file ~f:(fun out -> run_analyze_transactions_file ~timeout filename out)
